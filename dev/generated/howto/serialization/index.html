<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Serialization · AbstractImageReconstruction.jl</title><meta name="title" content="Serialization · AbstractImageReconstruction.jl"/><meta property="og:title" content="Serialization · AbstractImageReconstruction.jl"/><meta property="twitter:title" content="Serialization · AbstractImageReconstruction.jl"/><meta name="description" content="Documentation for AbstractImageReconstruction.jl."/><meta property="og:description" content="Documentation for AbstractImageReconstruction.jl."/><meta property="twitter:description" content="Documentation for AbstractImageReconstruction.jl."/><meta property="og:url" content="https://github.com/JuliaImageRecon/AbstractImageReconstruction.jl/generated/howto/serialization/"/><meta property="twitter:url" content="https://github.com/JuliaImageRecon/AbstractImageReconstruction.jl/generated/howto/serialization/"/><link rel="canonical" href="https://github.com/JuliaImageRecon/AbstractImageReconstruction.jl/generated/howto/serialization/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AbstractImageReconstruction.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Example: Radon Reconstruction Package</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../example_intro/">Introduction</a></li><li><a class="tocitem" href="../../example/0_radon_data/">Radon Data</a></li><li><a class="tocitem" href="../../example/1_interface/">Interface</a></li><li><a class="tocitem" href="../../example/2_direct/">Direct Reconstruction</a></li><li><a class="tocitem" href="../../example/3_direct_result/">Direct Reconstruction Result</a></li><li><a class="tocitem" href="../../example/4_iterative/">Iterative Reconstruction</a></li><li><a class="tocitem" href="../../example/5_iterative_result/">Iterative Reconstruction Result</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">How to</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Serialization</a></li><li><a class="tocitem" href="../caching/">Caching</a></li><li><a class="tocitem" href="../observables/">Observables</a></li><li><a class="tocitem" href="../multi_threading/">Multi-Threading</a></li></ul></li><li><a class="tocitem" href="../../../API/api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to</a></li><li class="is-active"><a href>Serialization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Serialization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaImageRecon/AbstractImageReconstruction.jl/blob/main/docs/src/literate/howto/serialization.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Serialization"><a class="docs-heading-anchor" href="#Serialization">Serialization</a><a id="Serialization-1"></a><a class="docs-heading-anchor-permalink" href="#Serialization" title="Permalink"></a></h1><p>As was shown in the example, a <code>RecoPlan</code> <code>AbstractImageReconstruction</code> can be used to easily parametrize reconstruction algorithms or provide a template structure. Serializing and deserializing a plan can therefore be used to provide templates of algorithms as well as storing a fully parametrized algorithm to reproduce a reconstruction later on. The main goal of serialization is not to store and restore the concrete binary representation of the algorithm, but to store the parameters and the structure of the algorithm. Changes to parameters or algorithms internals could thus still be supported by a deserialized plan, as long as the keyword arguments of the constructor are still valid.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Serialization is still in an experimental state and might change in the future. It is intended as a best-effort feature to provide a way to store and load plans. Depending on the Julia version, the reconstruction package in question and the complexity of custom structs used in the parameters, serialization might not work as expected.</p></div></div><p><code>RecoPlans</code> are serialized as TOML files using the <a href="https://docs.julialang.org/en/v1/stdlib/TOML/">TOML.jl</a> standard library:</p><pre><code class="language-julia hljs">pre = RadonPreprocessingParameters(frames = collect(1:3))
back_reco = RadonBackprojectionParameters(;angles)
algo_back = DirectRadonAlgorithm(DirectRadonParameters(pre, back_reco))
plan = toPlan(algo_back)
clear!(plan)
#toTOML(stdout, plan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RecoPlan{Main.OurRadonReco.DirectRadonParameters}
├─ reco::RecoPlan{Main.OurRadonReco.RadonBackprojectionParameters}
│  └─ angles
└─ pre::RecoPlan{Main.OurRadonReco.RadonPreprocessingParameters}
   ├─ numAverages
   └─ frames
</code></pre><p>Before serialization as a TOML file, the plan is turned into a nested dictionary using the functions <code>toDict, toDict!, toDictValue</code> and <code>toDictValue!</code>. The top-level function is <code>toDict</code>:</p><pre><code class="language-julia hljs">toDict(plan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 3 entries:
  &quot;parameter&quot; =&gt; Dict{String, Any}(&quot;reco&quot;=&gt;Dict{String, Any}(&quot;_module&quot;=&gt;Main.__…
  &quot;_module&quot;   =&gt; Main.OurRadonReco
  &quot;_type&quot;     =&gt; RecoPlan{DirectRadonAlgorithm}</code></pre><p>This method creates a dictionary and records not only the value of the argument, but also the module and type name among other metadata. This metadata starts with a <code>_</code> and is used during deserialization to recreate the correct types. After creating the dictionary, the function <code>toDict!</code> is called to add the argument and its metadata to the dictionary.</p><p>The value-representation of the argument is added to the dictionary using the <code>toDictValue!</code> method. The default <code>toDictValue!</code> for structs with fields adds each field of the argument as a key-value pair with the value being provided by the <code>toDictValue</code> function.</p><p>While <code>AbstractImageReconstruction</code> tries to provide default implementations, multiple dispatch can be used for custom serialization of types.</p><p>As an example we will add a new parameter struct for a filtered backprojection process using a given geometry:</p><pre><code class="language-julia hljs">export CustomGeomFilteredBackprojectionParameters
Base.@kwdef struct CustomGeomFilteredBackprojectionParameters{G &lt;: RadonGeometry} &lt;: OurRadonReco.AbstractDirectRadonReconstructionParameters
  angles::Vector{Float64}
  filter::Union{Nothing, Vector{Float64}} = nothing
  geometry::G
end
function AbstractImageReconstruction.process(::Type{&lt;:AbstractDirectRadonAlgorithm}, params::CustomGeomFilteredBackprojectionParameters, data::AbstractArray{T, 3}) where {T}
  return RadonKA.backproject_filtered(data, params.angles; filter = params.filter, geometry = params.geometry)
end</code></pre><p>First we will take a look at the default serialization:</p><pre><code class="language-julia hljs">reco = RecoPlan(CustomGeomFilteredBackprojectionParameters; angles = [0.0],
        geometry = RadonFlexibleCircle(size(sinograms, 1), [0.0, 0.0], [1.0, 1.0]))
toTOML(stdout, reco)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">_module = &quot;Main&quot;
_type = &quot;RecoPlan{Main.CustomGeomFilteredBackprojectionParameters}&quot;
angles = [0.0]

[geometry]
weights = [1.0, 1.0]
N = 63
in_height = [0.0, 0.0]
_module = &quot;RadonKA&quot;
_type = &quot;RadonFlexibleCircle&quot;
out_height = [1.0, 1.0]</code></pre><p>In this case the default seems to work, but we can also provide a custom serialization for the geometry. This is especially helpful for custom types that contain large amounts of data, which we don&#39;t want to serialize. An example of this could be a file with meeasurement data, where we just want to store the file path and not the whole data.</p><p>We want to serialize the geometry as a custom dictionary. For that we first need to override the default <code>toDictValue</code> method for the geometry:</p><pre><code class="language-julia hljs">AbstractImageReconstruction.toDictValue(value::RadonGeometry) = toDict(value)</code></pre><p>This method is called when the fields for the <code>CustomGeomFilteredBackprojectionParameters</code> are serialized.</p><p>Now that we create a custom dict representation, we can override the behaviour after the metadata is recorded. For that we specialize the <code>toDictValue!</code> method:</p><pre><code class="language-julia hljs">function AbstractImageReconstruction.toDictValue!(dict, value::RadonFlexibleCircle)
  dict[&quot;in&quot;] = value.in_height
  dict[&quot;out&quot;] =  value.out_height
  dict[&quot;N&quot;] = value.N
end</code></pre><p>This results in our custom serialization:</p><pre><code class="language-julia hljs">toTOML(stdout, reco)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">_module = &quot;Main&quot;
_type = &quot;RecoPlan{Main.CustomGeomFilteredBackprojectionParameters}&quot;
angles = [0.0]

[geometry]
out = [1.0, 1.0]
N = 63
_module = &quot;RadonKA&quot;
_type = &quot;RadonFlexibleCircle&quot;
in = [0.0, 0.0]</code></pre><p>We also need to create the corresponding deserialization functions. This is done by defining a <code>fromTOML</code> method for the type. Since we defined our value to be represented as a dictionary, we will need to construct our type from a dictionary:</p><pre><code class="language-julia hljs">function AbstractImageReconstruction.fromTOML(::Type{&lt;:RadonGeometry}, dict::Dict{String, Any})
  return RadonFlexibleCircle(dict[&quot;N&quot;], dict[&quot;in&quot;], dict[&quot;out&quot;])
end</code></pre><p>Finally, we can do a round-trip test to see if our serialization and deserialization works:</p><pre><code class="language-julia hljs">io = IOBuffer()
toTOML(io, reco)
seekstart(io)
recoCopy = loadPlan(io, [Main, OurRadonReco, RadonKA])
toTOML(stdout, recoCopy)</code></pre><p>For deserialization we need to provide the module where the type is defined. This is necessary to &quot;find&quot; the correct type during deserialization that allows for the dispatch to the correct <code>fromTOML</code> method. Generally, this module selection can be done by the reconstruction package developer, though it is also possible for the user to add modules since they can easily extend algorithms with new processing steps.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../example/5_iterative_result/">« Iterative Reconstruction Result</a><a class="docs-footer-nextpage" href="../caching/">Caching »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 28 January 2025 16:40">Tuesday 28 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
