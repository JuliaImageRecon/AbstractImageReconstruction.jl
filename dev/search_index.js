var documenterSearchIndex = {"docs":
[{"location":"generated/example/4_iterative/","page":"Iterative Reconstruction","title":"Iterative Reconstruction","text":"include(\"../../literate/example/1_interface.jl\") #hide\nusing RadonKA #hide\nexport AbstractIterativeRadonReconstructionParameters, IterativeRadonReconstructionParameters, IterativeRadonParameters, IterativeRadonAlgorithm #hide","category":"section"},{"location":"generated/example/4_iterative/#Iterative-Reconstruction","page":"Iterative Reconstruction","title":"Iterative Reconstruction","text":"In this section we implement a more complex iterative reconstruction algorithm. We will use iterative solvers provided by RegularizedLeastSquares.jl. These solver feature a variety of arguments, in this example we will just focus on the parameters for the number of iterations and regularization. Each solver requires either a matrix or a matrix-free linear operator which implements multiplication with a vector as input. We will use LinearOperatorCollection.jl, which implements a wrapper around RadonKA.\n\nFor this example, we will further assume that the construction of this operator is costly and should be done only once. This means our algorithm will be stateful and has to store the operator.","category":"section"},{"location":"generated/example/4_iterative/#Parameters-and-Processing","page":"Iterative Reconstruction","title":"Parameters and Processing","text":"We will start by defining the parameters for the algorithm and the processing steps. Afterwards we can implement the algorithm itself. Since we will use the same preprocessing as for the direct reconstruction, we can reuse the parameters and processing steps and jump directly to the iterative parameters:\n\nusing RegularizedLeastSquares, LinearOperatorCollection\nabstract type AbstractIterativeRadonReconstructionParameters <: AbstractRadonReconstructionParameters end\nBase.@kwdef struct IterativeRadonReconstructionParameters{S <: AbstractLinearSolver, R <: AbstractRegularization, N} <: AbstractIterativeRadonReconstructionParameters\n  solver::Type{S}\n  iterations::Int64\n  reg::Vector{R}\n  shape::NTuple{N, Int64}\n  angles::Vector{Float64}\nend\n\nThe parameters of this struct can be grouped into three catergories. The solver type just specifies which solver to use. The number of iterations and the regularization term could be abstracted into a nested AbstractRadonParameter which describe the parameters for the solver. Lastly the shape and angles are required to construct the linear operator.\n\nSince we want to construct the linear operator only once, we will write the process method with the operator as a given argument:\n\nfunction AbstractImageReconstruction.process(::Type{<:AbstractIterativeRadonAlgorithm}, params::IterativeRadonReconstructionParameters, op, data::AbstractArray{T, 4}) where {T}\n  solver = createLinearSolver(params.solver, op; iterations = params.iterations, reg = params.reg)\n\n  result = similar(data, params.shape..., size(data, 4))\n\n  for i = 1:size(data, 4)\n    result[:, :, :, i] = solve!(solver, vec(data[:, :, :, i]))\n  end\n\n  return result\nend\n\nLater we need to define to create the operator and pass it to this process method.","category":"section"},{"location":"generated/example/4_iterative/#Algorithm","page":"Iterative Reconstruction","title":"Algorithm","text":"Similar to the direct reconstruction algorithm, we want our iterative algorithm to accept both preprocessing and reconstruction parameters. We will encode this in a new type:\n\nBase.@kwdef struct IterativeRadonParameters{P<:AbstractRadonPreprocessingParameters, R<:AbstractIterativeRadonReconstructionParameters} <: AbstractRadonParameters\n  pre::P\n  reco::R\nend\n\nInstead of defining essentially the same struct again, we could also define a more generic one and specify the supported reconstruction parameter as type constraints in the algorithm constructor.\n\nUnlike the direct reconstruction algorithm, the iterative algorithm has to store the linear operator. We will store it as a field in the algorithm type:\n\nmutable struct IterativeRadonAlgorithm{D <: IterativeRadonParameters} <: AbstractIterativeRadonAlgorithm\n  parameter::D\n  op::Union{Nothing, AbstractLinearOperator}\n  output::Channel{Any}\nend\n\nWe will set the operator to nothing in the constructor:\n\nfunction IterativeRadonAlgorithm(parameter::D) where D\n  return IterativeRadonAlgorithm{D}(parameter, nothing, Channel{Any}(Inf))\nend\n\nNext we implement the process method for our reconstruction parameters and an algorithm instance. This allows us to access the operator and pass it to the processing step:\n\nfunction AbstractImageReconstruction.process(algo::IterativeRadonAlgorithm, params::IterativeRadonParameters{P, R}, data::AbstractArray{T, 4}) where {T, P<:AbstractRadonPreprocessingParameters, R<:AbstractIterativeRadonReconstructionParameters}\n  data = process(algo, params.pre, data)\n  return process(algo, params.reco, algo.op, data)\nend\n\nNote that initially the operator is nothing and the processing step would fail as it stands. To \"fix\" this we define a process method for the algorithm instance which creates the operator and stores it in the algorithm:\n\nfunction AbstractImageReconstruction.process(algo::IterativeRadonAlgorithm, params::AbstractIterativeRadonReconstructionParameters, ::Nothing, data::AbstractArray{T, 4}) where {T}\n  op = RadonOp(T; shape = params.shape, angles = params.angles)\n  algo.op = op\n  return process(AbstractIterativeRadonAlgorithm, params, op, data)\nend\n\nOur algorithm is not type stable. To fix this, we would need to know the element type of the sinograms during construction. Which is possible with a different parameterization of the algorithm. We will not do this here. Often times the performance impact of this is negligible as the critical sections are in the preprocessing or the iterative solver, especially since we still dispatch on the operator.\n\nTo finish up the implementation we need to implement the remaining runtime related functions:\n\nBase.take!(algo::IterativeRadonAlgorithm) = Base.take!(algo.output)\nfunction Base.put!(algo::IterativeRadonAlgorithm, data::AbstractArray{T, 4}) where {T}\n  lock(algo.output) do\n    put!(algo.output, process(algo, algo.parameter, data))\n  end\nend\nBase.lock(algo::IterativeRadonAlgorithm) = lock(algo.output)\nBase.unlock(algo::IterativeRadonAlgorithm) = unlock(algo.output)\nBase.isready(algo::IterativeRadonAlgorithm) = isready(algo.output)\nBase.wait(algo::IterativeRadonAlgorithm) = wait(algo.output)\nAbstractImageReconstruction.parameter(algo::IterativeRadonAlgorithm) = algo.parameter\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/example/5_iterative_result/","page":"Iterative Reconstruction Result","title":"Iterative Reconstruction Result","text":"include(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/example/5_iterative_result/#Iterative-Reconstruction-Result","page":"Iterative Reconstruction Result","title":"Iterative Reconstruction Result","text":"We can now use the iterative algorithms to reconstruct the first three images of our time series. We first prepare our parameters. For this example we will use the Conjugate Gradient Normal Residual solver with 20 iterations and a L2 regularization of 0.001. Furthermore, we will project the final result to positive values:\n\npre = RadonPreprocessingParameters(frames = collect(1:3))\niter_reco = IterativeRadonReconstructionParameters(; shape = size(images)[1:3], angles = angles, iterations = 20, reg = [L2Regularization(0.001), PositiveRegularization()], solver = CGNR);\nnothing #hide\n\nAgain we can construct the algorithm with our parameters:\n\nalgo_iter = IterativeRadonAlgorithm(IterativeRadonParameters(pre, iter_reco));\nnothing #hide\n\nAnd apply it to our sinograms:\n\nimag_iter = reconstruct(algo_iter, sinograms);\nnothing #hide\n\nFinally we can visualize the results:\n\nfig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_iter[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig\n\nAs was already mentioned for the direct reconstruction, the iterative algorithm also needs to be recreated for any parameter change. This can already be quite tedious with the number of parameters we have here. To make this process easier, we can use the RecoPlan feature of AbstractImageReconstruction. This allows us to define a plan for the reconstruction, which can then be used to easily reconstruct the images.","category":"section"},{"location":"generated/example/5_iterative_result/#RecoPlan","page":"Iterative Reconstruction Result","title":"RecoPlan","text":"A RecoPlan is a thin-wrapper around nested key-value pairs that represent the same tree structure of our algorithm and parameters. The plan can be fully parametertized and then used to create the algorithm. But it can also miss parameters and describe the structure of the algorithm only. This can be useful to create a template for the reconstruction, which can be filled with parameters later on.\n\nWe can create a plan from our algorithm:\n\nplan = toPlan(algo_iter)\n\nThe parameters of our plan can be accessed/traversed the same way as the algorithm:\n\nplan.parameter.pre.frames == algo_iter.parameter.pre.frames\n\nAnd each nested algorithm and parameter struct was converted to a plan:\n\ntypeof(plan.parameter.pre)\n\nUnlike the algorithm, we can easily change the parameters of the plan:\n\nplan.parameter.reco.iterations = 30\nplan.parameter.pre.frames = collect(1:5)\n\nInstead of traversing the properties of the plan/algorithm, we can also use the setAll! function to set all parameters of the same of the plan at once:\n\nsetAll!(plan, :solver, FISTA);\nnothing #hide\n\nThis also works with dictionaries of symbols and values:\n\ndict = Dict{Symbol, Any}(:reg => [L1Regularization(0.001)])\nsetAll!(plan, dict);\nnothing #hide\n\nOnce we have parametertized our plan, we can build the algorithm from it:\n\nalgo_iter = build(plan)\nimag_iter = reconstruct(algo_iter, sinograms)\nfig = Figure()\nfor i = 1:5\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_iter[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig\n\nIt's also possible to clear the plan and remove all set parameters. By default this preserves the structure of the plan. Such a plan can be used as a template for further reconstructions and stored as a TOML file:\n\ntoTOML(stdout, plan) # to save to file use `savePlan(\"path/to/file.toml\", plan)`\n\nAfter clearing we just have the structure of the plan left:\n\nclear!(plan)\ntoTOML(stdout, plan) # to save to file use `savePlan(\"path/to/file.toml\", plan)`\n\nNote that the serialization here is not the same as storing the binary representation of the algorithm or the RecoPlan. We essentially store key-value pairs which can be used in keyword-argument constructors to recreate the algorithm, however depending on the version of our Reco package, the underlying structs might change. It is also possible to define custom serialization and deserialization functions for a plan's parameters.\n\nFor more information on RecoPlan, see the how-to guides in the documentation.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/example/1_interface/#Interface","page":"Interface","title":"Interface","text":"This section introduces the abstract types we need to implement for our reconstruction package and how they relate to interface and types of AbstractImageReconstruction.jl.","category":"section"},{"location":"generated/example/1_interface/#Abstract-Types","page":"Interface","title":"Abstract Types","text":"We start by defining the abstract types we need to implement for our reconstruction package. AbstractImageReconstruction.jl provides two abstract types:\n\nabstract type AbstractImageReconstructionAlgorithm end\nabstract type AbstractImageReconstructionParameters end\n\nAbstractImageReconstructionAlgorithms represent a given reconstruction algorithm, while AbstractImageReconstructionParameters represent the parameters an algorithm was constructed with. Once constructed, algorithms can be used to reconstruct images repeatly and idealy without unecessary recomputations.\n\nFor our package we extend these abstract types with our own abstract subtypes:\n\nusing AbstractImageReconstruction\nexport AbstractRadonAlgorithm, AbstractRadonParameters, AbstractRadonPreprocessingParameters, AbstractRadonReconstructionParameters, AbstractDirectRadonAlgorithm, AbstractIterativeRadonAlgorithm, RadonPreprocessingParameters # hide\nabstract type AbstractRadonAlgorithm <: AbstractImageReconstructionAlgorithm end\nabstract type AbstractRadonParameters <: AbstractImageReconstructionParameters end\n\nLater on we will have parameters that are shared between different algorithms and parameters for different processings steps of a reconstruction. In our case we will have preprocessing parameters and reconstruction parameters. For these we introduce the following abstract types:\n\nabstract type AbstractRadonPreprocessingParameters <: AbstractRadonParameters end\nabstract type AbstractRadonReconstructionParameters <: AbstractRadonParameters end\n\nSince we want to implement both direct and iterative methods for our reconstruction, we introduce the following abstract types:\n\nabstract type AbstractDirectRadonAlgorithm <: AbstractRadonAlgorithm end\nabstract type AbstractIterativeRadonAlgorithm <: AbstractRadonAlgorithm end","category":"section"},{"location":"generated/example/1_interface/#Internal-Interface","page":"Interface","title":"Internal Interface","text":"Reconstruction algorithms in AbstractImageReconstruction.jl are expected to be implemented in the form of distinct processing steps, implemented in their own process methods. The process function takes an algorithm, parameters, and inputs and returns the result of the processing step. If no function is defined for an instance of an algorithm, the default implementation is called. This method tries to call the function process with the type of the algorithm:\n\nprocess(algo::AbstractImageReconstructionAlgorithm, param::AbstractImageReconstructionParameters, inputs...) = process(typeof(algo), param, inputs...)\n\nThe implementation of reconstruction algorithms is therefore expected to either implement the process function for the algorithm type or for the instance. Dispatch on instances allow an instance to change its state, while dispatch on types allows for pure helper functions.\n\nA process itself can invoke other process functions to enable multiple processing steps and generally have arbitarry control flow. It is not required to implement a straight-foward pipeline. We will see this later when we implementd our algorithms.\n\nLet's define a preprocessing step that we can share between our algorithms. We want to allow the user to select certain frames from a time series and average them. We will use the @kwdef macro to provide constructor with keyword arguments and default values\n\nusing Statistics\nBase.@kwdef struct RadonPreprocessingParameters <: AbstractRadonPreprocessingParameters\n  frames::Vector{Int64} = []\n  numAverages::Int64 = 1\nend\nfunction AbstractImageReconstruction.process(::Type{<:AbstractRadonAlgorithm}, params::RadonPreprocessingParameters, data::AbstractArray{T, 4}) where {T}\n  frames = isempty(params.frames) ? (1:size(data, 4)) : params.frames\n  data = data[:, :, :, frames]\n\n  if params.numAverages > 1\n    data = reshape(data, size(data)[1:3]..., params.numAverage, :)\n    data = dropdims(mean(data, dims = 4), dims = 4)\n  end\n\n  return data\nend","category":"section"},{"location":"generated/example/1_interface/#User-Interface","page":"Interface","title":"User Interface","text":"A user of our package should be able to reconstruct images by calling the reconstruct function. This function takes an algorithm and an input and returns the reconstructed image. Internally, the reconstruct function calls the put! and take! functions of the algorithm to pass the input and retrieve the output. Algorithms must implement these functions and are expected to have FIFO behavior.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/howto/multi_threading/","page":"Multi-Threading","title":"Multi-Threading","text":"include(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/howto/multi_threading/#Multi-Threading","page":"Multi-Threading","title":"Multi-Threading","text":"AbstractImageReconstruction assumes that algorithms are stateful. This is reflected in the FIFO behaviour and the locking interface of algorithms. The motivation behind this choice is that the nature of computations within an algorithms heavily impact if multi-threading is beneficial or not. For example, consider a GPU-accelerated reconstruction. There it might be faster to sequentially process all images on the GPU instead of processing them in parallel. Or consider, the preprocessing step of the Radon example where we average our data. If we were to extend our algorithm to read sinograms from a file, it might be inefficient to partially read and average frames from the file in parallel. Instead it would be more efficient to read the required file in one go and then average the frames in parallel. Therefore, the actual runtime behaviour is intended to be an implementation detail of an algorithm which is to be abstracted behind reconstruct.\n\nIn the following we will explore the results of this design decision. If we consider a n algorithm such as:\n\nplan = RecoPlan(IterativeRadonAlgorithm, parameter = RecoPlan(IterativeRadonParameters,\n  pre = RecoPlan(RadonPreprocessingParameters, frames = collect(1:5)),\n  reco = RecoPlan(IterativeRadonReconstructionParameters, shape = size(images)[1:3], angles = angles,\n            iterations = 20, reg = [L2Regularization(0.001), PositiveRegularization()], solver = CGNR)\n))\nalgo = build(plan)\n\nwhich acts on one frame at a time, we could in theory do:\n\nThreads.@threads for i = 1:size(sinograms, 4)\n res = reconstruct(algo, sinograms[:, :, :, i:i])\n # Store res\nend\n\nDue to the locking interface of the algorithm, this will not actually run in parallel. Instead the algorithm will be locked for each iteration and tasks will wait for the previous reconstruction to finish.\n\nIf a user wants to explicitly use multi-threading, we could the plan to create a new algorithm for each task:\n\nThreads.@threads for i = 1:size(sinograms, 4)\n  algo = build(plan)\n  res = reconstruct(algo, sinograms[:, :, :, i:i])\n  # Store res\nend\n\nThis way each task has its own algorithm and can run in parallel. As mentioned before, this parallelization might not be the most efficient parallel reconstruction, both in terms of memory and runtime.\n\nTo further improve the performance of the reconstruction, we could implement specific multi-threading process-ing steps for our algorithms. As an example, we will implement parallel processing for the iterative solver:\n\nBase.@kwdef struct ThreadedIterativeReconstructionParameters{S <: AbstractLinearSolver, R <: AbstractRegularization, N} <: AbstractIterativeRadonReconstructionParameters\n  solver::Type{S}\n  iterations::Int64\n  reg::Vector{R}\n  shape::NTuple{N, Int64}\n  angles::Vector{Float64}\nend\n\nOur parameters are identical to the iterative reconstruction parameters from the iterative example. We only differ in the type of the parameters. This allows us to dispatch on the type of the parameters and implement a different process method for the threaded version:\n\nfunction AbstractImageReconstruction.process(::Type{<:AbstractIterativeRadonAlgorithm}, params::ThreadedIterativeReconstructionParameters, op, data::AbstractArray{T, 4}) where {T}\n\n  result = similar(data, params.shape..., size(data, 4))\n\n  Threads.@threads for i = 1:size(data, 4)\n    solver = createLinearSolver(params.solver, op; iterations = params.iterations, reg = params.reg)\n    result[:, :, :, i] = solve!(solver, vec(data[:, :, :, i]))\n  end\n\n  return result\nend\n\nWhile the Radon operator is thread-safe, the normal operator constructed by the solver is not. Therefore, we can reuse the Radon operator but still have to construct new solvers for each task.\n\nOur multi-threaded reconstruction can be constructed and used just like the single-threaded one::\n\nplan.parameter.pre.frames = collect(1:size(sinograms, 4))\nplan.parameter.reco = RecoPlan(ThreadedIterativeReconstructionParameters, shape = size(images)[1:3], angles = angles,\n            iterations = 20, reg = [L2Regularization(0.001), PositiveRegularization()], solver = CGNR)\n\nalgo = build(plan)\nimag_iter = reconstruct(algo, sinograms)\nfig = Figure()\nfor i = 1:5\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_iter[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/example/3_direct_result/","page":"Direct Reconstruction Result","title":"Direct Reconstruction Result","text":"include(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/example/3_direct_result/#Direct-Reconstruction-Result","page":"Direct Reconstruction Result","title":"Direct Reconstruction Result","text":"Now that we have implemented our direct reconstruction algorithm, we can use it to reconstruct for example the first three images of our time series. We first prepare our parameters:\n\npre = RadonPreprocessingParameters(frames = collect(1:3))\nback_reco = RadonBackprojectionParameters(;angles)\nfilter_reco = RadonFilteredBackprojectionParameters(;angles);\nnothing #hide\n\nThen we can construct the algorithms:\n\nalgo_back = DirectRadonAlgorithm(DirectRadonParameters(pre, back_reco))\nalgo_filter = DirectRadonAlgorithm(DirectRadonParameters(pre, filter_reco));\nnothing #hide\n\nAnd apply them to our sinograms:\n\nimag_back = reconstruct(algo_back, sinograms)\nimag_filter = reconstruct(algo_filter, sinograms);\nnothing #hide\n\nFinally we can visualize the results:\n\nfig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_back[:, :, 24, i]))\n  plot_image(fig[i,4], reverse(imag_filter[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig\n\nTo add new functionality to our direct reconstruction algorithm, we can simply add new preprocessing or reconstruction parameters and implement the according processing steps. This way we can easily extend our algorithm to support new features. We can also define our own file format to store the results of our reconstruction algorithms or dispatch our preprocessing on files and pass files instead of the sinograms directly.\n\nThe way we use the algorithms here, requires the user to reconstruct the algorithm for each changed parameter. After we implement the more complex iterative reconstructions, we will take a look at how to make this process more manageable.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/howto/observables/","page":"Observables","title":"Observables","text":"include(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/howto/observables/#Observables","page":"Observables","title":"Observables","text":"Observables from Observables.jl are containers which can invoke callbacks whenever their stored value is changed. Each property of a RecoPlan is an Òbservable to which functions can be attached. These function listen to changes of the Observables value. This can be used to store \"logic\" about the parameter within a plan, such as a function to update and visualize the current state of a plan or to calculate default values whenever a parameter changes.\n\nIn this documentation we will focus on the interaction between RecoPlans and Observables. For more details on the Observables API we refer to the package and Makie documentation.\n\nusing Observables\nplan = RecoPlan(DirectRadonAlgorithm; parameter = RecoPlan(DirectRadonParameters;\n        pre = RecoPlan(RadonPreprocessingParameters; frames = collect(1:3)),\n        reco = RecoPlan(RadonBackprojectionParameters; angles = angles)))\n\nYou can interact with parameters as if they are \"normal\" properties of a nested struct, which we shown in previous examples:\n\nlength(plan.parameter.pre.frames) == 3\n\nInternally, these properties are stored as Observables to which we can attach functions:\n\non(plan.parameter.pre, :frames) do val\n  @info \"Number of frames: $(length(val))\"\nend\nsetAll!(plan, :frames, collect(1:42))\n\nClearing the plan also resets the Observables and removes all listeners:\n\nclear!(plan)\nsetAll!(plan, :frames, collect(1:3))\nplan.parameter.pre.frames\n\nTo directly access the Observable of a property you can use getindex on the plan with the property name:\n\nplan.parameter.pre[:frames]\n\nObservables can also be used to connect two properties of a plan. For example, we can set the number of averages to the number of frames:\n\non(plan.parameter.pre, :frames) do val\n  plan.parameter.pre.numAverages = length(val)\nend\nsetAll!(plan, :frames, collect(1:42))\nplan.parameter.pre.numAverages\n\nIt is important to avoid circular dependencies when connecting Observables, as this can lead to infinite loops of callbacks. Also note that the connection shown above will always overwrite the number of averages even if a user has set the value manually:\n\nplan.parameter.pre.numAverages = 5\nsetAll!(plan, :frames, collect(1:42))\nplan.parameter.pre.numAverages\n\nTo connect two properties without overwriting user-prvided values, we can use the LinkedPropertyListener provided by AbstractImageReconstruction:\n\nclear!(plan)\nlistener = LinkedPropertyListener(plan.parameter.pre, :numAverages, plan.parameter.pre, :frames) do val\n  @info \"Setting default numAverages value to: $(length(val))\"\n  return length(val)\nend\nplan.parameter.pre.frames = collect(1:42)\nplan.parameter.pre.numAverages = 1\nplan.parameter.pre.frames = collect(1:3)\n\nThe LinkedPropertyListener can also be serialized and deserialized with the plan. However, for the function to be properly serialized, it should be a named function:\n\nclear!(plan)\ndefaultAverages(val) = length(val)\nLinkedPropertyListener(defaultAverages, plan.parameter.pre, :numAverages, plan.parameter.pre, :frames)\nplan.parameter.pre.frames = collect(1:42)\n@info plan.parameter.pre.numAverages == 42\ntoTOML(stdout, plan)\n\nTo serialize custom listener one can inherit from AbstractPlanListener and follow the serialization How-To to implement the serialization. Listener are deserialized after the plan is built and the parameters are set. This means that the listener can access the parameters of the plan and the plan itself. For deserialization the listener has to implement loadListener!(::Type{<:AbstractPlanListener}, plan::RecoPlan, field::Symbol, dict::Dict{String, Any}, args...).\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/example/0_radon_data/#Radon-Data","page":"Radon Data","title":"Radon Data","text":"In this example we will set up our radon data using RadonKA.jl, ImagePhantoms.jl and ImageGeoms.jl. We will start with simple 2D images and their sinograms and continue with a time series of 3D images and sinograms.","category":"section"},{"location":"generated/example/0_radon_data/#Background","page":"Radon Data","title":"Background","text":"The Radon transform is an integral transform that projects the values of a function(or a phantom) along straight lines onto a detector. These projections are recorded for a number of different angles and form the so-called sinogram. The Radon transform and its adjoint form the mathematical basis for computed tomography (CT) and other imaging modalities such as single photon emission computed tomography (SPECT) and positron emission tomography (PET).","category":"section"},{"location":"generated/example/0_radon_data/#2D-Phantom","page":"Radon Data","title":"2D Phantom","text":"We will use a simple Shepp-Logan phantom to generate our Radon data. The phantom is a standard test image for medical imaging and consists of a number of ellipses with different intensities. It can be generated using ImagePhantoms.jl and ImageGeoms.jl. as follows:\n\nusing ImagePhantoms, ImageGeoms\nN = 256\nimage = shepp_logan(N, SheppLoganToft())\nsize(image)\n\nThis produces a 256x256 image of a Shepp-Logan phantom. Next, we will generate the Radon data using radon from RadonKA.jl. The arguments of this function are the image or phantom to be transformed, the angles at which the projections are taken, and the used geometry of the system. For this example we will use the default parallel circle geometry. For more details, we refer to the RadonKA.jl documentation. We will use 256 angles for the projections, between 0 and π.\n\nusing RadonKA\nangles = collect(range(0, π, 256))\nsinogram = Array(RadonKA.radon(image, angles))\nsize(sinogram)\n\nTo visualize our progress so far, we will use CairoMakie.jl and a small helper function:\n\nusing CairoMakie\nfunction plot_image(figPos, img; title = \"\", width = 150, height = 150)\n  ax = CairoMakie.Axis(figPos[1, 1]; yreversed=true, title, width, height)\n  hidedecorations!(ax)\n  hm = heatmap!(ax, img)\n  Colorbar(figPos[1, 2], hm)\nend\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], sinogram, title = \"Sinogram\")\nresize_to_layout!(fig)\nfig","category":"section"},{"location":"generated/example/0_radon_data/#3D-Pnantom","page":"Radon Data","title":"3D Pnantom","text":"RadonKA.jl also supports 3D Radon transforms. The first two dimensions are interpreted as the XY plane where the transform applied and the last dimensions is the rotational axis z of the projections. For that we need to create a 3D Shepp-Logan phantom. First we retrieve the parameters of the ellipsoids of the Shepp-Logan phantom:\n\nshape = (64, 64, 64)\nparams = map(collect, ellipsoid_parameters(; fovs = shape));\nnothing #hide\n\nWe then scale the intensities of the ellipsoids to [0.0, ..., 1.0]:\n\ntoft_settings = [1.0, -0.8, -0.2, -0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\nfor idx in eachindex(toft_settings)\n  params[idx][10] = toft_settings[idx]\nend\n\nFinally, we create the 3D Shepp-Logan phantom by defining and sampling our image geometry:\n\nob = ellipsoid(map(Tuple, params))\nig = ImageGeom(;dims = shape)\nimage = phantom(axes(ig)..., ob)\nsize(image)\n\nNow we can compute the 3D Radon transform of our phantom:\n\nsinogram = Array(RadonKA.radon(image, angles))\nsize(sinogram)\n\nLet's visualize the 3D Radon data:\n\nfig = Figure()\nplot_image(fig[1,1], reverse(image[26,:,:]), title = \"Slice YZ at z=26\")\nplot_image(fig[1,2], image[:,40,:], title = \"Slice XZ at y=40\")\nplot_image(fig[2,1], reverse(image[:, :, 24]), title = \"Slice XY at z=24\")\nplot_image(fig[2,2], reverse(sinogram[:,:,24]), title = \"Sinogram at z=24\")\nplot_image(fig[3,1], reverse(image[:, :,16]), title = \"Slice XY at z=16\")\nplot_image(fig[3,2], reverse(sinogram[:,:,16]), title = \"Sinogram at z=16\")\nresize_to_layout!(fig)\nfig","category":"section"},{"location":"generated/example/0_radon_data/#Time-Series-of-3D-Phantoms","page":"Radon Data","title":"Time Series of 3D Phantoms","text":"Lastly, we want to add a time dimension to our 3D phantom. For our example we will increase the intensity of the third ellipsoid every time step or frame.\n\nimages = similar(image, size(image)..., 5)\nsinograms = similar(sinogram, size(sinogram)..., 5)\nfor (i, intensity) in enumerate(range(params[3][end], 0.3, 5))\n  params[3][end] = intensity\n  local ob = ellipsoid(map(Tuple, params))\n  local ig = ImageGeom(;dims = shape)\n  images[:, :, :, i] = phantom(axes(ig)..., ob)\n  sinograms[:, :, :, i] = Array(RadonKA.radon(images[:, :, :, i], angles))\nend\nsize(sinograms)\n\nfig = Figure()\nfor i = 1:5\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\nend\nresize_to_layout!(fig)\nfig\n\nThe goal of our reconstruction package is now to recover an approximation of the time-series 3D phantoms from a given time-series of sinograms. In the next section we will introduce our class hierarchies and explore the API of AbstractImageReconstruction.jl.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/howto/caching/","page":"Caching","title":"Caching","text":"include(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/howto/caching/#Caching","page":"Caching","title":"Caching","text":"Image reconstruction algorithms can be computationally expensive. To avoid unnecessary recomputations, we can cache the results of processing steps. This can be especially helpful if a user wants to change parameters of an algorithm that only impact parts of the processing. We have seen a small example of caching in the IterativeRadonAlgorithm implementation. There the algorithm itself cached a result in its properties. AbstractImageReconstruction provides a more general caching mechanism that can be used for any processing step. However, the caching mechanism is not enabled by default and has to be explicitly implemented by the algorithm developer.\n\nThis How-To builds on the results of the example sections.","category":"section"},{"location":"generated/howto/caching/#ProcessResultCache","page":"Caching","title":"ProcessResultCache","text":"The caching mechanism is based on the ProcessResultCache type. This type wraps around a different AbstractImageReconstructionParameter and caches the result of a processing step. Such a processing step which offer functionality to other process steps is a AbstractUtilityReconstructionParameter. These utility steps should return the same result as if the inner step was called directly.\n\nThe cache itself is connected to a RecoPlan and any instances build from the same plan instance share this cache and can reuse the result of the processing step.\n\nLet's implement the ProcessResultCache type for the Radon preprocessing step. We first define a struct a very costly preprocessing step:\n\nBase.@kwdef struct CostlyPreprocessingParameters <: AbstractRadonPreprocessingParameters\n  frames::Vector{Int64} = []\n  runtime::Float64 = 1.0\nend\nfunction AbstractImageReconstruction.process(::Type{<:AbstractRadonAlgorithm}, params::CostlyPreprocessingParameters, data::AbstractArray{T, 4}) where {T}\n  frames = isempty(params.frames) ? (1:size(data, 4)) : params.frames\n  data = data[:, :, :, frames]\n  @info \"Very costly preprocessing step\"\n  sleep(params.runtime)\n  return data\nend\n\nNow we can define a processing step that internally uses another processing step. We allow this inner parameter to be cached by considering the following Union:\n\nBase.@kwdef struct RadonCachedPreprocessingParameters{P <: AbstractRadonPreprocessingParameters, PU <: AbstractUtilityReconstructionParameters{P}} <: AbstractRadonPreprocessingParameters\n  params::Union{P, PU}\nend\n\nNote that this case is a bit artifical and a more sensible place would be the algorithm parameters themselves. However, for the case of simplicity we did not introduce the concept in the example. In this artifical case we just pass the parameters to the processing step. A real implementation might do some more processing with the result of the inner processing step:\n\nAbstractImageReconstruction.process(algoT::Type{<:AbstractRadonAlgorithm}, params::RadonCachedPreprocessingParameters, args...) = process(algoT, params.params, args...)\n\nWe deliberaly implement the process function for algorithm type to avoid our cache being invalided by state changes of an algoritm instance.\n\nNow we construct a plan for a direct reconstruction algorithm that uses the costly preprocessing step:\n\npre = CostlyPreprocessingParameters(; frames = collect(1:3), runtime = 1.0)\npreCached = RadonCachedPreprocessingParameters(ProcessResultCache(pre, maxsize = 2))\nprePlan = toPlan(preCached)\nrecoPlan = RecoPlan(IterativeRadonReconstructionParameters; angles = angles, shape = size(images)[1:3],\n            iterations = 10, reg = [L2Regularization(0.001), PositiveRegularization()], solver = CGNR)\nparams = RecoPlan(IterativeRadonParameters; pre = prePlan, reco = recoPlan)\nplan = RecoPlan(IterativeRadonAlgorithm; parameter = params)\n\nWhen we built the algorithm from the plan, the costly preprocessing step is only executed once and the result is cached and can be reused:\n\nalgo = build(plan)\nreconstruct(algo, sinograms);\nreconstruct(algo, sinograms);\nnothing #hide\n\nIf we change the parameters of the algorithms without affecting the preprocessing step, we can still reuse the cached result:\n\nsetAll!(plan, :iterations, 5)\nalgo = build(plan)\nreconstruct(algo, sinograms);\nplan.parameter.reco.iterations == 5\n\nProcessResultCache uses a least recently used (LRU) strategy to store the results. The cache size can be set by the user and defaults to 1. If the cache is full, the least recently used result is removed from the cache.\n\nThe cache is checked with a key formed with the hash of all arguments of the processing step. AbstractImageReconstruction provides a default hash method for AbstractImageReconstructionParameters`, which hashes all properties of a parameter.\n\nOther methods of cache invalidation are creating a new plan or manual invalidation of the cache:\n\nempty!(algo.parameter.pre.params)\nreconstruct(algo, sinograms);\nnothing #hide\n\nCaches support serialization like other RecoPlans:\n\nclear!(plan)\ntoTOML(stdout, plan)\n\nCaches can also be resized. You can either set the maxsize property of the RecoPlan or use resize! on the ProcessResultCache. Resizing a cache affects all algorithms build from the same plan.\n\nsetAll!(plan, :maxsize, 0)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/example/2_direct/","page":"Direct Reconstruction","title":"Direct Reconstruction","text":"include(\"../../literate/example/1_interface.jl\") #hide\nusing RadonKA #hide\nexport AbstractDirectRadonReconstructionParameters, RadonFilteredBackprojectionParameters, RadonBackprojectionParameters, DirectRadonParameters, DirectRadonAlgorithm #hide","category":"section"},{"location":"generated/example/2_direct/#Direct-Reconstruction","page":"Direct Reconstruction","title":"Direct Reconstruction","text":"To implement our direct reconstruction algorithms we need to define a few more methods and types. We will start by defining the parameters for the backprojection and for the filtered backprojection. Afterwards we can implement the algorithm itself.","category":"section"},{"location":"generated/example/2_direct/#Parameters-and-Processing","page":"Direct Reconstruction","title":"Parameters and Processing","text":"For convenience we first introduce a new abstract type for the direct reconstruction paramters:\n\nabstract type AbstractDirectRadonReconstructionParameters <: AbstractRadonReconstructionParameters end\n\nThe backprojection parameters are simple and only contain the number of angles:\n\nBase.@kwdef struct RadonBackprojectionParameters <: AbstractDirectRadonReconstructionParameters\n  angles::Vector{Float64}\nend\n\nThe filtered backprojection parameters are more complex and contain the number of angles and optionally the filter which should be used:\n\nBase.@kwdef struct RadonFilteredBackprojectionParameters <: AbstractDirectRadonReconstructionParameters\n  angles::Vector{Float64}\n  filter::Union{Nothing, Vector{Float64}} = nothing\nend\n\nSince we have defined no default values for the angles, they are required to be set by the user. A more advanced implementation would also allow for the geometry to be set.\n\nNext we will implement the process steps for both of our backprojection variants. Since RadonKA.jl expects 2D or 3D arrays we have to transform our time series accordingly.\n\nfunction AbstractImageReconstruction.process(algoT::Type{<:AbstractDirectRadonAlgorithm}, params::AbstractDirectRadonReconstructionParameters, data::AbstractArray{T, 4}) where {T}\n  result = []\n  for i = 1:size(data, 4)\n    push!(result, process(algoT, params, view(data, :, :, :, i)))\n  end\n  return cat(result..., dims = 4)\nend\nAbstractImageReconstruction.process(::Type{<:AbstractDirectRadonAlgorithm}, params::RadonBackprojectionParameters, data::AbstractArray{T, 3}) where {T} = RadonKA.backproject(data, params.angles)\nAbstractImageReconstruction.process(::Type{<:AbstractDirectRadonAlgorithm}, params::RadonFilteredBackprojectionParameters, data::AbstractArray{T, 3}) where {T} = RadonKA.backproject_filtered(data, params.angles; filter = params.filter)","category":"section"},{"location":"generated/example/2_direct/#Algorithm","page":"Direct Reconstruction","title":"Algorithm","text":"The direct reconstruction algorithm has essentially no state to store between reconstructions and thus only needs its parameters as fields. We want our algorithm to accept any combination of our preprocessing and direct reconstruction parameters. This we encode in a new type:\n\nBase.@kwdef struct DirectRadonParameters{P <: AbstractRadonPreprocessingParameters, R <: AbstractDirectRadonReconstructionParameters} <: AbstractRadonParameters\n  pre::P\n  reco::R\nend\n\nAnd the according processing step:\n\nfunction AbstractImageReconstruction.process(algoT::Type{<:AbstractDirectRadonAlgorithm}, params::DirectRadonParameters{P, R}, data::AbstractArray{T, 4}) where {T, P<:AbstractRadonPreprocessingParameters, R<:AbstractDirectRadonReconstructionParameters}\n  data = process(algoT, params.pre, data)\n  return process(algoT, params.reco, data)\nend\n\nNow we can define the algorithm type itself. Algorithms are usually constructed with one argument passing in the user parameters:\n\nmutable struct DirectRadonAlgorithm{D <: DirectRadonParameters} <: AbstractDirectRadonAlgorithm\n  parameter::D\n  output::Channel{Any}\n  DirectRadonAlgorithm(parameter::D) where D = new{D}(parameter, Channel{Any}(Inf))\nend\n\nAnd they implement a method to retrieve the used parameters:\n\nAbstractImageReconstruction.parameter(algo::DirectRadonAlgorithm) = algo.parameter\n\nAlgorithms are assumed to be stateful. To ensure thread safety, we need to implement the lock and unlock functions. We will use the output channel as a lock:\n\nBase.lock(algo::DirectRadonAlgorithm) = lock(algo.output)\nBase.unlock(algo::DirectRadonAlgorithm) = unlock(algo.output)\n\nAnd implement the put! and take! functions, mimicking the behavior of a FIFO channel for reconstructions:\n\nBase.take!(algo::DirectRadonAlgorithm) = Base.take!(algo.output)\nfunction Base.put!(algo::DirectRadonAlgorithm, data::AbstractArray{T, 4}) where {T}\n  lock(algo) do\n    put!(algo.output, process(algo, algo.parameter, data))\n  end\nend\n\nThe way the behaviour is implemented here, the algorithm does not buffer any inputs and instead blocks until the currenct reconstruction is done. Outputs are stored until they are retrieved.\n\nWith wait and isready we can check if the algorithm is currently processing data or if it is ready to accept new inputs:\n\nBase.wait(algo::DirectRadonAlgorithm) = wait(algo.output)\nBase.isready(algo::DirectRadonAlgorithm) = isready(algo.output)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/howto/serialization/","page":"Serialization","title":"Serialization","text":"include(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/howto/serialization/#Serialization","page":"Serialization","title":"Serialization","text":"As was shown in the example, a RecoPlan AbstractImageReconstruction can be used to easily parametrize reconstruction algorithms or provide a template structure. Serializing and deserializing a plan can therefore be used to provide templates of algorithms as well as storing a fully parametrized algorithm to reproduce a reconstruction later on. The main goal of serialization is not to store and restore the concrete binary representation of the algorithm, but to store the parameters and the structure of the algorithm. Changes to parameters or algorithms internals could thus still be supported by a deserialized plan, as long as the keyword arguments of the constructor are still valid.\n\nwarning: Warning\nSerialization is still in an experimental state and might change in the future. It is intended as a best-effort feature to provide a way to store and load plans. Depending on the Julia version, the reconstruction package in question and the complexity of custom structs used in the parameters, serialization might not work as expected.\n\nRecoPlans are serialized as TOML files using the TOML.jl standard library:\n\npre = RadonPreprocessingParameters(frames = collect(1:3))\nback_reco = RadonBackprojectionParameters(;angles)\nalgo_back = DirectRadonAlgorithm(DirectRadonParameters(pre, back_reco))\nplan = toPlan(algo_back)\nclear!(plan)\n#toTOML(stdout, plan)\n\nBefore serialization as a TOML file, the plan is turned into a nested dictionary using the functions toDict, toDict!, toDictValue and toDictValue!. The top-level function is toDict:\n\ntoDict(plan)\n\nThis method creates a dictionary and records not only the value of the argument, but also the module and type name among other metadata. This metadata starts with a _ and is used during deserialization to recreate the correct types. After creating the dictionary, the function toDict! is called to add the argument and its metadata to the dictionary.\n\nThe value-representation of the argument is added to the dictionary using the toDictValue! method. The default toDictValue! for structs with fields adds each field of the argument as a key-value pair with the value being provided by the toDictValue function.\n\nWhile AbstractImageReconstruction tries to provide default implementations, multiple dispatch can be used for custom serialization of types.\n\nAs an example we will add a new parameter struct for a filtered backprojection process using a given geometry:\n\nexport CustomGeomFilteredBackprojectionParameters\nBase.@kwdef struct CustomGeomFilteredBackprojectionParameters{G <: RadonGeometry} <: OurRadonReco.AbstractDirectRadonReconstructionParameters\n  angles::Vector{Float64}\n  filter::Union{Nothing, Vector{Float64}} = nothing\n  geometry::G\nend\nfunction AbstractImageReconstruction.process(::Type{<:AbstractDirectRadonAlgorithm}, params::CustomGeomFilteredBackprojectionParameters, data::AbstractArray{T, 3}) where {T}\n  return RadonKA.backproject_filtered(data, params.angles; filter = params.filter, geometry = params.geometry)\nend\n\nFirst we will take a look at the default serialization:\n\nreco = RecoPlan(CustomGeomFilteredBackprojectionParameters; angles = [0.0],\n        geometry = RadonFlexibleCircle(size(sinograms, 1), [0.0, 0.0], [1.0, 1.0]))\ntoTOML(stdout, reco)\n\nIn this case the default seems to work, but we can also provide a custom serialization for the geometry. This is especially helpful for custom types that contain large amounts of data, which we don't want to serialize. An example of this could be a file with meeasurement data, where we just want to store the file path and not the whole data.\n\nWe want to serialize the geometry as a custom dictionary. For that we first need to override the default toDictValue method for the geometry:\n\nAbstractImageReconstruction.toDictValue(value::RadonGeometry) = toDict(value)\n\nThis method is called when the fields for the CustomGeomFilteredBackprojectionParameters are serialized.\n\nNow that we create a custom dict representation, we can override the behaviour after the metadata is recorded. For that we specialize the toDictValue! method:\n\nfunction AbstractImageReconstruction.toDictValue!(dict, value::RadonFlexibleCircle)\n  dict[\"in\"] = value.in_height\n  dict[\"out\"] =  value.out_height\n  dict[\"N\"] = value.N\nend\n\nThis results in our custom serialization:\n\ntoTOML(stdout, reco)\n\nWe also need to create the corresponding deserialization functions. This is done by defining a fromTOML method for the type. Since we defined our value to be represented as a dictionary, we will need to construct our type from a dictionary:\n\nfunction AbstractImageReconstruction.fromTOML(::Type{<:RadonGeometry}, dict::Dict{String, Any})\n  return RadonFlexibleCircle(dict[\"N\"], dict[\"in\"], dict[\"out\"])\nend\n\nFinally, we can do a round-trip test to see if our serialization and deserialization works:\n\nio = IOBuffer()\ntoTOML(io, reco)\nseekstart(io)\nrecoCopy = loadPlan(io, [Main, OurRadonReco, RadonKA])\ntoTOML(stdout, recoCopy)\n\nFor deserialization we need to provide the module where the type is defined. This is necessary to \"find\" the correct type during deserialization that allows for the dispatch to the correct fromTOML method. Generally, this module selection can be done by the reconstruction package developer, though it is also possible for the user to add modules since they can easily extend algorithms with new processing steps.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"example_intro/#Small-Reconstruction-Package-for-Radon-projections","page":"Introduction","title":"Small Reconstruction Package for Radon projections","text":"In this example we will implement a small image reconstruction package using AbstractImageReconstruction.jl. Our reconstruction package OurRadonreco aims to provide direct and iterative reconstruction algorithms for Radon projection data. \n\nMost of the desired functionality is already implemented in various Julia packages. Our reconstruction package now needs to properly link these packages and transform the data into the appropriate formats for each package. \n\nnote: Note\nThe example is intended for developers of reconstruction packages that use AbstractImageReconstruction. End-users of such a package can consult the result sections of the example to see the high-level interface of AbstractImagerReconstruction and should otherwise consult the documentation of the concrete reconstruction package itself.","category":"section"},{"location":"example_intro/#Installation","page":"Introduction","title":"Installation","text":"We can install AbstractImageReconstruction using the Julia package manager. Open a Julia REPL and run the following command:\n\nusing Pkg\nPkg.add(\"AbstractImageReconstruction\")\n\nThis will download and install AbstractImageReconstruction.jl and its dependencies. To install a different version, please consult the Pkg documentation. In addition to AbstractImageReconstruction.jl, we will need a few more packages to get started, which we can install the same way.\n\nRadonKA.jl provides us with fast Radon forward and backward projections, which we can use for direct reconstructions and to prepare sample data for our package.\n\nLinearOperatorCollection.jl wraps the functionality of RadonKA.jl into a matrix-free linear operator, that can be used in iterative solvers.\n\nRegularizedLeastSquares.jl offers a variety of iterative solvers and regularization options.\n\nImagePhantoms.jl and ImageGeoms.jl allow us to define digital software \"phantoms\", which we will use to test our reconstruction algorithms.\n\nLastly, we will use CairoMakie.jl to visualize our results.","category":"section"},{"location":"example_intro/#Outline","page":"Introduction","title":"Outline","text":"Radon Data: this section we will familiarise ourselves with RadonKA.jl and define a small data format for three-dimensional time series sinograms. We also create the inverse problem that we will solve in the rest of the example\n\nInterface: Here we define the abstract types we will use in our package and take a look at what we need to implement to interact with AbstractImageReconstruction. We also start with a first processing step of our algorithms.\n\nDirect Reconstruction: Now we extend our abstract types with a concrete implementation of reconstruction algorithms using the backprojection and filtered backprojection.\n\nDirect Reconstruction Result: This section shows how to use the algorithm we have just implemented.\n\nIterative Reconstruction: We finish our small example package by implementing an iterative reconstruction algorithm. For this algorithm we require more complex parametrization and data processing.\n\nIterative Reconstruction Result: The last section shows again how to use the just implemented algorithm. But it also highlights RecoPlans, which are a core utility of AbstractImageReconstruction. These plans allow a user to easily configure, save and load algorithms as templates.\n\nFor an even more detailed reconstruction package we refer to the magnetic particle imaging reconstruction package MPIReco.jl.","category":"section"},{"location":"API/api/#API-for-Solvers","page":"API Reference","title":"API for Solvers","text":"This page contains documentation of the public API of the AbstractImageReconstruction. In the Julia REPL one can access this documentation by entering the help mode with ?","category":"section"},{"location":"API/api/#Algorithm-and-Parameters","page":"API Reference","title":"Algorithm and Parameters","text":"","category":"section"},{"location":"API/api/#RecoPlan","page":"API Reference","title":"RecoPlan","text":"","category":"section"},{"location":"API/api/#Miscellaneous","page":"API Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"API/api/#AbstractImageReconstruction.AbstractImageReconstructionAlgorithm","page":"API Reference","title":"AbstractImageReconstruction.AbstractImageReconstructionAlgorithm","text":"AbstractImageReconstructionAlgorithm\n\nAbstract type for image reconstruction algorithms. Must implement put! and take! functions. Serialization expects a constructor with a single AbstractImageReconstructionParameters argument.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#AbstractImageReconstruction.reconstruct","page":"API Reference","title":"AbstractImageReconstruction.reconstruct","text":"reconstruct(algo::T, u) where {T<:AbstractImageReconstructionAlgorithm}\n\nReconstruct an image from input u using algorithm algo. The àlgo will be locked until the result is available or an error occurs.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#Base.put!-Tuple{AbstractImageReconstructionAlgorithm, Any}","page":"API Reference","title":"Base.put!","text":"put!(algo::AbstractImageReconstructionAlgorithm, inputs...)\n\nPerform image reonstruction with algorithm algo on given ìnputs. Depending on the algorithm this might block. Result is stored and can be retrieved with take!.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.take!-Tuple{AbstractImageReconstructionAlgorithm}","page":"API Reference","title":"Base.take!","text":"take!(algo::AbstractImageReconstructionAlgorithm)\n\nRemove and return a stored result from the algorithm algo. Blocks until a result is available.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.lock-Tuple{AbstractImageReconstructionAlgorithm}","page":"API Reference","title":"Base.lock","text":"lock(algo::AbstractImageReconstructionAlgorithm)\n\nAcquire a lock on the algorithm algo. If the lock is already acquired, wait until it is released.\n\nEach lock must be matched with a unlock.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.unlock-Tuple{AbstractImageReconstructionAlgorithm}","page":"API Reference","title":"Base.unlock","text":"unlock(algo::AbstractImageReconstructionAlgorithm)\n\nRelease a lock on the algorithm algo.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.isready-Tuple{AbstractImageReconstructionAlgorithm}","page":"API Reference","title":"Base.isready","text":"isready(algo::AbstractImageReconstructionAlgorithm)\n\nDetermine if the algorithm algo has a result available.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.wait-Tuple{AbstractImageReconstructionAlgorithm}","page":"API Reference","title":"Base.wait","text":"wait(algo::AbstractImageReconstructionAlgorithm)\n\nWait for a result to be available from the specified algo.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#AbstractImageReconstruction.AbstractImageReconstructionParameters","page":"API Reference","title":"AbstractImageReconstruction.AbstractImageReconstructionParameters","text":"AbstractImageReconstructionParameters\n\nAbstract type for image reconstruction parameters.  An algorithm consists of one ore more process steps, each can have its own parameters. Parameters can be arbitrarly nested. \n\n\n\n\n\n","category":"type"},{"location":"API/api/#AbstractImageReconstruction.process","page":"API Reference","title":"AbstractImageReconstruction.process","text":"process(algo::Union{A, Type{A}}, param::AbstractImageReconstructionParameters, inputs...) where A <: AbstractImageReconstructionAlgorithm\n\nProcess inputs with algorithm algo and parameters param. Returns the result of the processing step. If not implemented for an instance of algo, the default implementation is called with the type of algo.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.parameter","page":"API Reference","title":"AbstractImageReconstruction.parameter","text":"parameter(algo::AbstractImageReconstructionAlgorithm)\n\nReturn the parameters of the algorithm algo.\n\n\n\n\n\nparameter(param::AbstractUtilityReconstructionParameters)\n\nReturn the wrapped parameter. Can themselves be utility parameters again\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.RecoPlan","page":"API Reference","title":"AbstractImageReconstruction.RecoPlan","text":"RecoPlan{T <: Union{AbstractImageReconstructionParameters, AbstractImageReconstructionAlgorithm}}\n\nConfiguration template for an image reconstruction algorithm or paremeters of type T.  A RecoPlan{T} has the same properties with type checking as T with the exception that properties can be missing and nested algorithms and parameters can again be RecoPlans.\n\nPlans can be nested and form a tree. A parent plan can be accessed with parent and set with parent!. Algorithms and parameters can be converted to a plan with toPlan.\n\nPlans feature serialization with toTOML, toPlan and loadPlan and the ability to attach callbacks to property changes with Òbservables and on.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#Base.propertynames-Tuple{RecoPlan}","page":"API Reference","title":"Base.propertynames","text":"propertynames(plan::RecoPlan{T}) where {T}\n\nReturn a tupel of configurable properties of T. Unlike propertynames(T) this does not include properties starting with _.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.getproperty-Tuple{RecoPlan, Symbol}","page":"API Reference","title":"Base.getproperty","text":"getproperty(plan::RecoPlan{T}, name::Symbol) where {T}\n\nGet the property name of plan. Equivalent to plan.name.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.getindex-Tuple{RecoPlan, Symbol}","page":"API Reference","title":"Base.getindex","text":"getindex(plan::RecoPlan{T}, name::Symbol) where {T}\n\nReturn the Observable for the name property of plan. Equivalent to plan[name].\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.setproperty!-Tuple{RecoPlan, Symbol, Any}","page":"API Reference","title":"Base.setproperty!","text":"setproperty!(plan::RecoPlan{T}, name::Symbol, x::X) where {T, X}\n\nSet the property name of plan to x. Equivalent to plan.name = x. Triggers callbacks attached to the property.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#AbstractImageReconstruction.setAll!","page":"API Reference","title":"AbstractImageReconstruction.setAll!","text":"setAll!(plan::RecoPlan{T}, name::Symbol, x) where {T<:AbstractImageReconstructionParameters}\n\nRecursively set the property name of each nested RecoPlan of plan to x.\n\n\n\n\n\nsetAll!(plan::AbstractRecoPlan; kwargs...)\n\nCall setAll! with each given keyword argument.\n\n\n\n\n\nsetAll!(plan::AbstractRecoPlan, dict::Union{Dict{Symbol, Any}, Dict{String, Any}})\n\nCall setAll! with each entries of the dict.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.clear!","page":"API Reference","title":"AbstractImageReconstruction.clear!","text":"clear!(plan::RecoPlan{T}, preserve::Bool = true) where {T<:AbstractImageReconstructionParameters}\n\nClear all properties of plan. If preserve is true, nested RecoPlans are preserved.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#Base.ismissing-Tuple{RecoPlan, Symbol}","page":"API Reference","title":"Base.ismissing","text":"ismissing(plan::RecoPlan, name::Symbol)\n\nIndicate if the property name of plan is missing.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Observables.on-Tuple{Any, RecoPlan, Symbol}","page":"API Reference","title":"Observables.on","text":"on(f, plan::RecoPlan, property::Symbol; kwargs...)\n\nAdds function f as listener to property of plan. The function is called whenever the property is changed with setproperty!.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Observables.off-Tuple{RecoPlan, Symbol, Any}","page":"API Reference","title":"Observables.off","text":"off(plan::RecoPlan, property::Symbol, f)\n\nRemove f from the listeners of property of plan.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#AbstractImageReconstruction.build","page":"API Reference","title":"AbstractImageReconstruction.build","text":"build(plan::RecoPlan{T}) where {T}\n\nRecursively build a plan from a RecoPlan by converting all properties to their actual values using keyword argument constructors.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.toPlan","page":"API Reference","title":"AbstractImageReconstruction.toPlan","text":"toPlan(param::Union{AbstractImageReconstructionParameters, AbstractImageReconstructionAlgorithm})\n\nConvert an AbstractImageReconstructionParameters or AbstractImageReconstructionAlgorithm to a (nested) RecoPlan.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.savePlan","page":"API Reference","title":"AbstractImageReconstruction.savePlan","text":"savePlan(file::Union{AbstractString, IO}, plan::RecoPlan)\n\nSave the plan to the file in TOML format. See also loadPlan, toTOML, toDict.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.loadPlan","page":"API Reference","title":"AbstractImageReconstruction.loadPlan","text":"loadPlan(filename::Union{AbstractString, IO}, modules::Vector{Module})\n\nLoad a RecoPlan from a TOML file. The modules argument is a vector of modules that contain the types used in the plan. After loading the plan, the listeners are attached to the properties using loadListener!.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.loadListener!","page":"API Reference","title":"AbstractImageReconstruction.loadListener!","text":"loadListener!(plan, name::Symbol, dict, modDict)\n\nLoad a listener from dict and attach it to property name of plan\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractTrees.parent-Tuple{RecoPlan}","page":"API Reference","title":"AbstractTrees.parent","text":"parent(plan::RecoPlan)\n\nReturn the parent of plan.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#AbstractImageReconstruction.parent!-Tuple{RecoPlan, AbstractRecoPlan}","page":"API Reference","title":"AbstractImageReconstruction.parent!","text":"parent!(plan::RecoPlan, parent::RecoPlan)\n\nSet the parent of plan to parent.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#AbstractImageReconstruction.parentproperty","page":"API Reference","title":"AbstractImageReconstruction.parentproperty","text":"parentproperty(plan::RecoPlan)\n\nReturn the property name of plan in its parent, s.t. getproperty(parent(plan), parentproperty(plan)) === plan. Return nothing if plan has no parent.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.parentproperties","page":"API Reference","title":"AbstractImageReconstruction.parentproperties","text":"parentproperties(plan::RecoPlan)\n\nReturn a vector of property names of plan in its parent, s.t. getproperty(parent(plan), last(parentproperties(plan))) === plan. Return an empty vector if plan has no parent.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.LinkedPropertyListener","page":"API Reference","title":"AbstractImageReconstruction.LinkedPropertyListener","text":"LinkedPropertyListener(fn, target::RecoPlan, targetProp, source::RecoPlan, sourceProp)\n\nConnect two properties of RecoPlans. Set target.targetProp to fn(source.sourceProp) whenever source.sourceProp changes and target.targetProp was not changed outside of the listener.  \n\n\n\n\n\n","category":"type"},{"location":"API/api/#AbstractImageReconstruction.ProcessResultCache","page":"API Reference","title":"AbstractImageReconstruction.ProcessResultCache","text":"ProcessResultCache(params::AbstractImageReconstructionParameters; maxsize = 1, kwargs...)\n\nCache of size maxsize for the result of process methods. The cache is based on the hash of the inputs of the process function. Cache is shared between all algorithms constructed from the same plan. The cache is transparent for properties of the underlying parameter. Cache can be invalidated by calling empty! on the cache.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#Base.hash-Tuple{AbstractImageReconstructionParameters, UInt64}","page":"API Reference","title":"Base.hash","text":"hash(parameter::AbstractImageReconstructionParameters, h)\n\nDefault hash function for image reconstruction paramters. Uses nameof the parameter and all fields not starting with _ to compute the hash.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#AbstractImageReconstruction.toKwargs-Tuple{AbstractImageReconstructionParameters}","page":"API Reference","title":"AbstractImageReconstruction.toKwargs","text":"toKwargs(value::AbstractImageReconstructionParameters; kwargs...)\n\nConvert a AbstractImageReconstructionParameters to a Dict{Symbol, Any} of each property.\n\nOptional keyword arguments:\n\nflatten::Vector{DataType}: Types to flatten, per default only AbstractImageReconstructionParameters are flattened.\nignore::Vector{Symbol}: Properties to ignore.\ndefault::Dict{Symbol, Any}: Default values for properties that are missing.\noverwrite::Dict{Symbol, Any}: Overwrite values for properties.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#AbstractImageReconstruction.fromKwargs","page":"API Reference","title":"AbstractImageReconstruction.fromKwargs","text":"fromKwargs(type::Type{T}; kwargs...) where {T}\n\nCreate a new instance of type from the keyword arguments. Only properties that are part of type are considered.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.toDict","page":"API Reference","title":"AbstractImageReconstruction.toDict","text":"toDict(value)\n\nRecursively convert value to a Dict{String, Any} using toDict!.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.toDict!","page":"API Reference","title":"AbstractImageReconstruction.toDict!","text":"toDict!(dict, value)\n\nExtracts metadata such as the module and type name from value and adds it to dict. The value-representation of value is added using toDictValue!.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.toDictValue","page":"API Reference","title":"AbstractImageReconstruction.toDictValue","text":"toDictValue(value)\n\nTransform value to a value-representation in a dict that can later be serialized as a TOML file.\n\n\n\n\n\n","category":"function"},{"location":"API/api/#AbstractImageReconstruction.toDictValue!","page":"API Reference","title":"AbstractImageReconstruction.toDictValue!","text":"toDictValue!(dict, value)\n\nExtracts the value-representation of value and adds it to dict. The default implementation for structs with fields adds each field of the argument as a key-value pair with the value being provided by the toDictValue function.\n\n\n\n\n\ntoDictValue!(dict, plan::RecoPlan)\n\nAdds the properties of plan to dict using toDictValue for each not missing field. Additionally, adds each listener::AbstractPlanListener to the dict.\n\n\n\n\n\n","category":"function"},{"location":"#AbstractImageReconstruction.jl","page":"Home","title":"AbstractImageReconstruction.jl","text":"Abstract Interface for Medical Image Reconstruction Packages","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"AbstractImageReconstruction.jl is a Julia package that serves as the core API for medical imaging packages. It provides implementations an interface and type hierarchy to represent and implement image reconstruction algorithms, their parameters and runtime behaviour. In particular, this package serves as the API of the Julia packages MPIReco.jl.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Reconstruction control flow defined with multiple-dispatch on extensible and exchangable type hierarchies \nStoring, loading and manipulating of reconstruction algorithms with (partially) set parameters\nAttaching callbacks to parameter changes with Observables.jl\nVarious generic utilities such as transparent caching of intermediate reconstruction results","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Within Julia, use the package manager:\n\nusing Pkg\nPkg.add(\"AbstractImageReconstruction\")\n\nAbstractImageReconstruction is not intended to be used alone, but together with an image reconstruction package that implements the provided interface, such as MPIReco.jl.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"The actual construction of reconstruction algorithms depends on the implementation of the reconstruction package. Once an algorithm is constructed with the given parameters, images can be reconstructed as follows:\n\nusing AbstractImageReconstruction, MPIReco\n\nparams = ... # Setup reconstruction paramter\nalgo = ... # Setup chosen algorithm with params\nraw = ... # Setup raw data\n\nimage = reconstruct(algo, raw)\n\nAn algorithm can be transformed into a RecoPlan. These are mutable and transparent wrappers around the nested types of the algorithm and its parameters, which can be saved and restored to and from TOML files.\n\nplan = toPlan(algo)\nsavePlan(MPIReco, \"Example\", plan)\nplan = loadPlan(MPIReco, \"Example\", [MPIReco, RegularizedLeastSquares, MPIFiles])\n\nalgo2 = build(plan)\nalgo == algo2 # true\n\nUnlike concrete algorithm instances, a RecoPlan may still be missing certain values of its properties. Futhermore, they can encode the structure of an image reconstruction algorithm without concrete parameterization.\n\nIt is also possible to attach functions to RecoPlan properties, that call user-specified functions if they are changed using Observables.jl. This allows specific RecoPlans to provide smart default parameter choices or embedding a plan into a GUI.","category":"section"}]
}
